# Work Tracker Android Project Summary for AI Agent

This document serves as the foundational knowledge base for the AI agent to understand and align with the "Work Tracker" Android project. All future development activities should refer to and adhere to the principles, structures, and details outlined herein.

---

## 1) Complete App Structure

The "Work Tracker" application is designed to help users log their work activities, view history, generate reports, interact with an AI chatbot, and manage preferences including a master reset functionality.

### a) Brief App Routemap

The application's core navigation revolves around a bottom navigation bar, offering five primary destinations: Dashboard, History, Reports, ChatBot, and Preferences. These are top-level screens. Additionally, there are deeper navigation routes for logging new work activities, viewing details of a specific work activity, and a screen to view all logs (though largely superseded by History and Reports).

### b) App Navigation Routes

The application uses Jetpack Compose Navigation for managing screens.
The main navigation graph is defined in `MainActivity.kt` using `AppNavigationHost`.
The bottom navigation bar itself is constructed in `MainScreen.kt`, and its routes are defined in `BottomNavScreen.kt`.

**`AppRoutes` (defined in `MainActivity.kt`):**
*   `MAIN_SCREEN = "mainScreen"`: The entry point for the bottom navigation container.
*   `LOG_WORK_ACTIVITY = "logWorkActivity"`: Route for logging a new work activity.
*   `VIEW_LOGS = "viewLogs"`: Route for a generic view of logs (currently used minimally, mostly as a placeholder or specific list view).

**Bottom Navigation Routes (defined in `BottomNavScreen.kt` and used within `MainScreen.kt`):**
*   `Dashboard = "dashboard"`: Displays the primary dashboard with ongoing activities and quick actions.
*   `History = "history"`: Shows a history of logged work activities.
*   `Reports = "reports"`: Provides reporting functionalities.
*   `ChatBot = "chatbot"`: Integrates an AI chatbot for various interactions.
*   `Preferences = "preferences_route"`: Manages app-level settings and the master reset.

**Deep Link/Parameterized Routes:**
*   `ROUTE_WORK_DETAILS = "workDetails/{categoryName}"` (defined in `ui.screens.workdetails.WorkDetailsRoute`): Navigates to a specific work activity's details screen, requiring a `categoryName` argument.

### c) Details of Various Screens (Mentioned in succession as they are in the app navigation route)

1.  **`MainActivity.kt`**: The application's entry point, `ComponentActivity` that sets up `enableEdgeToEdge()` and the main `AppNavigationHost`.
2.  **`MainScreen.kt`**: The primary container screen that hosts the `BottomNavigationBar` and the `NavHost` for the bottom navigation destinations. It acts as a wrapper around the main content areas.
3.  **`DashboardScreen.kt` (Accessed via `BottomNavScreen.Dashboard`)**:
    *   **Purpose:** Displays the user's current work status, quick actions, and potentially ongoing activities.
    *   **Key Components:** Likely contains a button to start a new activity, a list of ongoing activities, and a summary of recent work.
    *   **ViewModel:** Uses `DashboardViewModel`.
4.  **`HistoryScreen.kt` (Accessed via `BottomNavScreen.History`)**:
    *   **Purpose:** Shows a historical list of all logged work activities. Currently displays an empty state if no logs exist.
    *   **Key Components:** `EmptyHistoryContent` composable which shows a "No work logs yet" message and a "Log Your First Activity" button.
    *   **ViewModel:** Will likely use `HistoryViewModel` in the future to fetch and display logs.
5.  **`ReportsHubScreen.kt` (Accessed via `BottomNavScreen.Reports`)**:
    *   **Purpose:** Provides an interface for users to generate and export reports of their work activities.
    *   **Key Components:** Buttons/options for different report types (e.g., PDF export), date range selectors.
    *   **ViewModel:** Uses `ReportsViewModel`.
6.  **`ChatBotScreen.kt` (Accessed via `BottomNavScreen.ChatBot`)**:
    *   **Purpose:** Allows users to interact with an integrated AI chatbot for queries related to their work data or general assistance.
    *   **Key Components:** Text input for messages, chat history display.
    *   **ViewModel:** Uses `ChatBotViewModel` which leverages `GeminiProService`.
7.  **`PreferencesScreen.kt` (Accessed via `BottomNavScreen.Preferences`)**:
    *   **Purpose:** Manages app-level settings, notably the "Master Reset" password and functionality.
    *   **Key Components:**
        *   A button to "Set Master Reset Password" or "Change Master Reset Password".
        *   A `SetPasswordDialog` for setting or modifying the password.
        *   A "Master Reset (Wipe All Data)" button (styled in red), visible only if a master password is set.
        *   A `ConfirmActionPasswordDialog` for confirming the master reset with the password.
        *   Snackbar messages for user feedback.
    *   **ViewModel:** Uses `PreferencesViewModel`.
8.  **`LogWorkActivityScreen.kt` (Accessed via `AppRoutes.LOG_WORK_ACTIVITY`)**:
    *   **Purpose:** Facilitates the logging of new work activities, allowing users to specify categories, descriptions, and start/end times.
    *   **Key Components:** Input fields for activity details, start/stop buttons.
    *   **ViewModel:** Uses `LogWorkActivityViewModel`.
9.  **`WorkDetailsRoute.kt` / `WorkDetailsScreen.kt` (Accessed via `ROUTE_WORK_DETAILS`)**:
    *   **Purpose:** Displays detailed information about a specific work activity log, identified by its category name.
    *   **Key Components:** Text views for details, potentially editing options.
    *   **ViewModel:** Uses `WorkDetailsViewModel`.
10. **`ViewLogsScreen.kt` (Accessed via `AppRoutes.VIEW_LOGS`)**:
    *   **Purpose:** A generic screen to view logs. Its usage might overlap with `HistoryScreen` but could be intended for specific filtered views or debugging.
    *   **Key Components:** Likely a list or table of work logs.
    *   **ViewModel:** `ViewLogsViewModel`.


### e) Any other details that might help with understanding the App

*   **Project Root:** `C:/Users/asus/AndroidStudioProjects/WorkTracker`
*   **Project Name:** `Work Tracker`
*   **Modules:** The project has 8 modules, with `Work_Tracker.app.main` being the primary application module where most development takes place.
*   **Edge-to-Edge Display:** The application is configured for edge-to-edge display using `enableEdgeToEdge()` in `MainActivity.kt`. This means content draws behind the system bars (status and navigation), and the theme handles only the appearance of the system bar icons (light/dark).
*   **Theming:** The application uses a custom, non-dynamic color theme defined in `ui/theme/Color.kt` and `ui/theme/Theme.kt`. The default `dynamicColor` parameter in `WorkTrackerTheme` is set to `false`.
*   **AI Integration:** The `GeminiProService` provides an interface for connecting to the Google Gemini Pro model for chatbot features.
*   **PDF Generation:** The `PdfGenerator.kt` utility handles the creation of PDF reports, which suggests interaction with local storage and potentially file sharing.

---

## 2) Coding Conventions and Techniques Used

The "Work Tracker" project adheres to modern Android development best practices, primarily leveraging Jetpack Compose and Hilt for a robust and maintainable architecture.

### a) List of all the good practices used in the architecture

*   **MVVM (Model-View-ViewModel) Architecture:** Clearly separates concerns:
    *   **View (Composables):** `*-Screen.kt` files are declarative UI, observing state from ViewModels and emitting events.
    *   **ViewModel:** `*-ViewModel.kt` files hold UI state, expose it as `StateFlow`, handle UI logic, and interact with repositories. They are lifecycle-aware.
    *   **Model (Data Layer):** Comprises `data` package, including `repository` interfaces/implementations and `database` (Room DAO/entities).
*   **Repository Pattern:** Abstracts data sources (local database, network, SharedPreferences) behind a clean API (`WorkActivityRepository`). This allows the ViewModel to remain agnostic to where data comes from.
*   **Dependency Injection (DI) with Hilt:** Promotes loose coupling, testability, and easier management of dependencies.
*   **Structured Concurrency with Kotlin Coroutines and Flows:** Asynchronous operations (database calls, AI requests) are managed using Kotlin Coroutines (`viewModelScope.launch`) and data streams are handled with Kotlin Flows (`StateFlow`, `MutableSharedFlow`).
*   **Single Source of Truth:** Data is primarily managed through the `WorkActivityRepository`, ensuring consistency.
*   **UI State Management:** ViewModels expose UI state via `StateFlow` for Composables to `collectAsState()`, ensuring reactive UI updates. `LaunchedEffect` is used for side effects like showing Snackbars.
*   **Separation of Concerns:** Distinct packages for `data`, `di`, `navigation`, `ui`, etc.
*   **Clear Naming Conventions:** Files and classes are named descriptively (e.g., `WorkActivityLog`, `PreferencesViewModel`).
*   **Immutability for UI State:** `data class PreferencesUiState(...)` ensures that UI state is immutable, simplifying state changes and preventing bugs.

### b) Details about things like Hilt DI etc. being used

*   **Hilt Setup:** Hilt is integrated into the project with `MyApplication.kt` annotated with `@HiltAndroidApp` and `MainActivity.kt` with `@AndroidEntryPoint`. ViewModels are injected using `@HiltViewModel`.
*   **`AppModule.kt` (`@Module`, `@InstallIn(SingletonComponent::class)`):** This is the core Hilt module providing singleton instances of key dependencies:
    *   **`SharedPreferences`:** Provided by `context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)`. This instance is used for storing key-value pairs like the `KEY_MASTER_PASSWORD`.
    *   **`GeminiProService`:** Provides the connection to the AI chatbot.
    *   **`WorkActivityRepository`:** The interface `WorkActivityRepository` is provided, with its concrete implementation `WorkActivityRepositoryImpl` being instantiated.
    *   **Room Database Components:** (Assumed to be provided via a separate `DatabaseModule.kt` or directly in `AppModule.kt` if simplified, often `WorkActivityDao` and `WorkActivityDatabase` would be here).
*   **Injected ViewModels:** ViewModels like `PreferencesViewModel` and `ReportsViewModel` use `@Inject constructor(...)` to receive their dependencies (e.g., `SharedPreferences`, `WorkActivityRepository`).

### c) Details about the UI (Mention what libraries and practises are used)

*   **Jetpack Compose:** The entire UI is built declaratively using Jetpack Compose, ensuring a modern Android UI toolkit.
*   **Material Design 3 (M3):** The application uses Material 3 components, indicated by imports like `androidx.compose.material3.*` and the `MaterialTheme` composable in `Theme.kt`. This includes components like `Scaffold`, `Button`, `Text`, `OutlinedTextField`, `AlertDialog`, `SnackbarHost`, etc.
*   **Compose Navigation:** `androidx.navigation:navigation-compose` is used for handling navigation between composable screens.
*   **Hilt Navigation Compose:** `androidx.hilt:hilt-navigation-compose` is used to facilitate injecting `ViewModel` instances directly into `Composable` functions using `hiltViewModel()`.
*   **State Management in Compose:**
    *   `collectAsState()`: Observes `StateFlow` from ViewModels and converts them into Compose `State`, triggering recomposition when data changes.
    *   `remember { ... }`: Used for remembering objects across recompositions, such as `SnackbarHostState`.
    *   `LaunchedEffect`: Handles side effects that need to be triggered in response to state changes (e.g., showing a snackbar message once and then clearing it).
*   **Image Vectors:** Uses `androidx.compose.material.icons.Icons` for various icons, including the `AutoMirrored` versions for better RTL (Right-to-Left) language support, resolving deprecation warnings.
*   **Edge-to-Edge Display:** Configured for a modern full-screen experience where app content extends behind the system bars, with system bar icon contrast managed by `WindowCompat`.

### d) Details of Databases used to store user input. (Explain in detail)

The application primarily uses the **Room Persistence Library** for structured data storage and **SharedPreferences** for simple key-value pairs.

*   **Room Persistence Library:**
    *   **`WorkActivityLog` (Entity):**
        *   Located at `data/database/entity/WorkActivityLog.kt`.
        *   This is the primary data model for individual work activity entries.
        *   It defines the schema for the `work_activity_logs` table in the SQLite database.
        *   Fields likely include `id` (primary key, auto-increment), `categoryName`, `description`, `startTime`, `endTime`, etc.
    *   **`WorkActivityDao` (Data Access Object):**
        *   Located at `data/database/dao/WorkActivityDao.kt`.
        *   An interface defining methods for interacting with the `work_activity_logs` table.
        *   **Key methods:**
            *   `insertLog(log: WorkActivityLog)`: Inserts or updates a work activity log (OnConflictStrategy.REPLACE).
            *   `getAllLogs()`: Returns a `Flow<List<WorkActivityLog>>` for observing all logs.
            *   `getLogById(id: Long)`: Retrieves a specific log by its ID.
            *   `deleteLogById(id: Long)`: Deletes a specific log by its ID.
            *   `getOngoingActivityByCategoryName(categoryName: String)`: Retrieves an active (endTime IS NULL) log for a category.
            *   `getOngoingActivities()`: Retrieves all active (endTime IS NULL) logs.
            *   `getRecentLogs()`: Retrieves the 5 most recent logs.
            *   **`clearAllLogsInternal()`:** A suspend function with `@Query("DELETE FROM work_activity_logs")` to delete all entries from the main log table.
            *   **`resetAutoIncrementForLogsTable()`:** A suspend function with `@Query("DELETE FROM sqlite_sequence WHERE name='work_activity_logs'")` to reset the auto-increment counter for the `work_activity_logs` table. This is crucial for truly "wiping" the database and ensuring new entries start from ID 1.
            *   **`wipeDatabaseAndResetIds()`:** An `@Transaction` suspend function that orchestrates both `clearAllLogsInternal()` and `resetAutoIncrementForLogsTable()`. This is the designated method for a complete "Master Reset" of work activity data.
    *   **`WorkActivityDatabase` (Database Class):**
        *   Located at `data/database/WorkActivityDatabase.kt`.
        *   An abstract class annotated with `@Database`, defining the entities (`WorkActivityLog`) and version.
        *   It provides the abstract `workActivityDao()` method to access the DAO.

*   **SharedPreferences:**
    *   **Purpose:** Used for storing lightweight, private data in key-value pairs, primarily the `KEY_MASTER_PASSWORD`.
    *   **`AppModule.kt`:** Provides a singleton instance of `SharedPreferences` named `"WorkTrackerUserPrefs"`.
    *   **`KEY_MASTER_PASSWORD`:** A constant defined in `AppModule.kt` (`"master_reset_password"`) acts as the key for storing the master reset password.
    *   **Usage (`PreferencesViewModel`):** The `PreferencesViewModel` injects `SharedPreferences` to `putString()` (save) and `getString()` (retrieve) the master password, as well as `contains()` to check if the password is set.

### e) Any other details that might be helpful in future activities which will develop the app.

*   **Testing:** As a good practice, unit and integration tests should be developed for ViewModels, Repositories, and DAOs. Mocking dependencies (especially `SharedPreferences` and `WorkActivityRepository` for ViewModel tests) will be crucial.
*   **Error Handling:** While some error handling (e.g., password validation) is present, robust error handling across network operations (if any are added) and database interactions should be a priority for new features. Use `Result` or `Either` types for more explicit error propagation.
*   **Stateful vs. Stateless Composables:** Distinguish between stateful composables (which hold and manage their own state, often for UI-specific, ephemeral state) and stateless composables (which receive all necessary state as parameters and expose events for state changes, improving reusability and testability). Aim for a higher proportion of stateless composables.
*   **One-Shot Events (Side Effects):** For non-UI state updates like navigation or showing a `Snackbar` that should only occur once per trigger, `MutableSharedFlow` is a good pattern (as initially set up for `_events` in `PreferencesViewModel`, though not actively used in the current version). This prevents events from being re-consumed on configuration changes or recompositions.
*   **Theme Consistency:** The custom Material Theme (defined in `ui/theme/Theme.kt`, `Color.kt`, `Type.kt`) ensures a consistent visual identity. When introducing new UI elements or screens, always utilize the `MaterialTheme.colorScheme` and `MaterialTheme.typography` to maintain this consistency. Avoid hardcoding colors or fonts directly unless absolutely necessary for a specific, isolated component.
*   **Accessibility:** Always consider accessibility when developing new UI components. Ensure `contentDescription` is provided for `Icon` and `Image` composables, proper focus management for interactive elements, and sufficient contrast ratios for text and UI elements, especially when designing new custom UI.
*   **Performance in Compose:** For lists of data (`LazyColumn`, `LazyRow`), ensure that `items` or `itemsIndexed` use a stable `key` parameter (e.g., a unique ID from the data model). This optimizes recomposition performance by allowing Compose to efficiently identify which items have changed.
*   **Security Considerations:**
    *   **Master Reset Password:** Currently stored in `SharedPreferences`. While suitable for simple local security, for extremely high-security applications, more robust encryption of this stored password (e.g., using `EncryptedSharedPreferences` from AndroidX Security) might be considered. For this application's scope, the current approach is deemed acceptable.
    *   **Sensitive Data:** Any other sensitive user data should also be handled with appropriate security measures, whether stored in the database (Room can encrypt the database, but requires additional libraries) or transmitted over a network (HTTPS).
*   **Localization (Internationalization):** Currently, all strings are hardcoded. For future support of multiple languages, all user-facing strings should be moved into `strings.xml` resources (e.g., `res/values/strings.xml`) and referenced using `stringResource(R.string.my_string_id)`.
*   **Version Control (Git):** The project is assumed to be under Git version control. All changes should be committed with clear, concise messages, and feature development should ideally occur on separate branches.
*   **Code Documentation:** Maintain clear and up-to-date documentation (Javadoc/KDoc) for classes, functions, and complex logic, especially for non-obvious implementations or business rules.

---

## 3) Agent Prompt

### a) After reading this prompt from a text file which will contain this summary, the AI agent in my android studio project should understand the project completely and thoroughly.

**To the AI Agent:**

"You have been provided with a comprehensive project summary for the 'Work Tracker' Android application. Your primary objective is to internalize this information completely and thoroughly. This document serves as your foundational understanding of the app's architecture, functionality, and established best practices.

**Key areas for your immediate focus and understanding:**

1.  **Core Purpose:** The app helps users track work activities, view history, generate reports, interact with an AI, and manage settings, including a critical master reset function.
2.  **Architectural Pattern:** MVVM is strictly followed. Understand the responsibilities of Views (Composables), ViewModels, and the Data Layer (Repositories, Room DAO/Entities).
3.  **Dependency Injection:** Hilt is the DI framework. Recognize `@Inject`, `@HiltViewModel`, `@Module`, and `@InstallIn` annotations and understand what dependencies are provided (e.g., `SharedPreferences`, `WorkActivityRepository`, `GeminiProService`).
4.  **UI Toolkit:** Jetpack Compose is the exclusive UI toolkit. Be familiar with composable functions, Material Design 3 components, `StateFlow` for UI state, and `LaunchedEffect` for side effects.
5.  **Navigation:** Jetpack Compose Navigation is used. Distinguish between top-level bottom navigation routes (`BottomNavScreen`) and deeper or parameterized routes. Always refer to `AppRoutes` and `BottomNavScreen` for route definitions.
6.  **Data Persistence:**
    *   **Room Database:** Used for `WorkActivityLog` entries. Understand the `WorkActivityDao` methods, especially `wipeDatabaseAndResetIds()` for the master reset.
    *   **SharedPreferences:** Used for simple key-value storage, specifically the `KEY_MASTER_PASSWORD`.
7.  **Key Features Implementation:**
    *   **Master Reset:** Understand its sensitive nature, the role of `PreferencesViewModel`, `SetPasswordDialog`, `ConfirmActionPasswordDialog`, and how it interacts with `SharedPreferences` and `WorkActivityRepository.clearAllLogs()`.
    *   **Theming:** Recognize the custom green theme and the use of `enableEdgeToEdge()` in `MainActivity` with corresponding `SideEffect` in `Theme.kt` for system bar icon appearance.
    *   **AI Integration:** Be aware of `GeminiProService` for chatbot functionality.
8.  **Warning Resolution Strategies:** Note the recent fixes for deprecated icons (using `AutoMirrored`) and system bar color assignments (relying on `enableEdgeToEdge()` and setting icon appearance). Apply similar modern practices when encountering new warnings or deprecations.

**Process for thorough understanding:**

*   **Read the entire summary carefully.**
*   **Correlate summary points with the actual code structure and file contents.** If a summary point mentions a file or method, mentally (or physically, if your tools allow) locate and review that code.
*   **Identify relationships:** Understand how `ViewModels` interact with `Repositories`, how `Repositories` interact with `DAOs` and `SharedPreferences`, and how `Composables` observe `ViewModel` state.
*   **Recognize patterns:** Look for recurring patterns in `ViewModel` state management (`StateFlow`, `_uiState.value.copy(...)`), `Composable` event handling, and dependency injection.
*   **Prioritize Security and Data Integrity:** Always be mindful of data handling, especially for sensitive operations like the Master Reset.

Your goal is to be able to answer detailed questions about *any* part of this project's current state, design decisions, and implementation choices without further prompting.

### b) Then the AI agent should align itself with this knowledge for any further development activities in the project.

**To the AI Agent:**

"Having thoroughly understood the 'Work Tracker' project based on the provided summary, you will now align your future assistance and development activities with this established knowledge base.

**This alignment means:**

*   **Adherence to Architecture:** All proposed code changes, new features, or refactorings *must* respect and extend the existing MVVM, Repository, and Hilt DI architecture. Do not introduce new architectural patterns or significant deviations unless explicitly instructed and justified.
*   **Consistent UI/UX:** When creating or modifying UI, utilize Jetpack Compose and Material Design 3. Maintain the established theming, color scheme, and typography. Prioritize accessibility and a consistent user experience.
*   **Leverage Existing Utilities:** Before implementing new functionality, check if existing services (`GeminiProService`), core utilities (`PdfGenerator`), or data access patterns (Room `WorkActivityDao`, `WorkActivityRepository`) can be leveraged or extended.
*   **Hilt for Dependencies:** All new dependencies should be managed via Hilt. When a new component requires dependencies, ensure they are provided through an appropriate Hilt module.
*   **Kotlin Coroutines & Flows:** Continue to use Kotlin Coroutines for asynchronous operations and Kotlin Flows for reactive data streams.
*   **Robust Data Handling:** Follow the established Room and SharedPreferences usage. For any new data persistence requirements, favor Room for structured data and SharedPreferences for simple settings.
*   **Security Mindset:** For any features involving sensitive user data or critical actions, immediately consider and implement appropriate security measures, consistent with (or improving upon) the current master password handling.
*   **No Redundant Code:** Avoid duplicating logic or UI components. Strive for reusable composables and utility functions.
*   **Address Warnings/Deprecations:** Always prioritize resolving compiler warnings and using non-deprecated APIs. Refer to the solutions implemented for the icon and system bar warnings as examples.
*   **Clear Communication:** When proposing changes or asking for clarification, reference specific files, lines of code, or sections of this summary to ensure precise communication.
*   **Incremental Development:** Propose changes in manageable steps (e.g., small, logical code edits followed by build verification) rather than large, monolithic modifications.
*   **Validate After Changes:** Always perform Gradle Sync, Clean, and Build operations after significant code changes and verify the output for errors or new warnings.

By adhering to this alignment, you will effectively act as an expert Android developer, seamlessly extending and maintaining the 'Work Tracker' application in a professional and efficient manner."
